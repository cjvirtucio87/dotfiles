.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Footprintless::Plugin::Database::AbstractProvider 3"
.TH Footprintless::Plugin::Database::AbstractProvider 3 "2018-01-11" "perl v5.26.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Footprintless::Plugin::Database::AbstractProvider \- A base class for database providers
.SH "VERSION"
.IX Header "VERSION"
version 1.04
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    my $db = $footprintless\->db(\*(Aqdev.db\*(Aq);
\&    $db\->execute(\*(Aqcreate table foo ( id int, name varchar(16) )\*(Aq);
\&
\&    my $rows_inserted = $db\->execute(
\&        q[
\&            insert into foo (id, name) values
\&                (1, \*(Aqfoo\*(Aq),
\&                (2, \*(Aqbar\*(Aq)
\&        ]);
\&
\&    my $name_of_1 = $db\->query_for_scalar(
\&        {
\&            sql => \*(Aqselect id, name from foo where id = ?\*(Aq,
\&            parameters => [1]
\&        },
\&        sub {
\&            my ($id, $name) = @_;
\&            return $name;
\&        });
\&
\&    my $rows_count = $db\->query_for_scalar(\*(Aqselect count(*) from foo\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Provides a base class implementing the common abstractions.  Other providers
should extend this class and override methods as desired.
.PP
There are a few core concepts used for the execute, and query methods.  They are
.PP
\fIquery\fR
.IX Subsection "query"
.PP
A string containing a sql statement, or a hashref with a required \f(CW\*(C`sql\*(C'\fR entry 
containing the sql statement and an optional \f(CW\*(C`parameters\*(C'\fR entry contianing a 
list of values for the placeholders of the prepared statement.  For example:
.PP
.Vb 4
\&    {
\&        sql => \*(Aqselect name, phone from employees where dept = ? and title = ?\*(Aq,
\&        parameters => [$dept, $title]
\&    }
.Ve
.PP
\fIrow_handler\fR
.IX Subsection "row_handler"
.PP
A callback that will be called once for each row.  It will be passed the list of
values requested in the query.  This callback does not return anything.
.PP
\fIrow_mapper\fR
.IX Subsection "row_mapper"
.PP
A callback that will be called once for each row.  It will be passed the list of
values requested in the query.  It must return a value that will be \fIcollected\fR
by the \f(CW\*(C`query_for_xxx\*(C'\fR method according to that methods behavior.
.SH "ENTITIES"
.IX Header "ENTITIES"
A simple deployment:
.PP
.Vb 7
\&    db => {
\&        provider => \*(Aqmysql\*(Aq,
\&        schema => \*(Aqmy_table\*(Aq,
\&        port => 3306,
\&        username => $properties\->{db.username},
\&        pasword => $properties\->{db.password}
\&    }
.Ve
.PP
A more complex situation, perhaps tunneling over ssh to your prod database:
.PP
.Vb 10
\&    db => {
\&        provider => \*(Aqpostgres\*(Aq,
\&        database => \*(Aqmy_database\*(Aq,
\&        schema => \*(Aqmy_table\*(Aq,
\&        hostname => \*(Aqmy.production.server\*(Aq,
\&        port => 5432,
\&        username => $properties\->{db.username},
\&        pasword => $properties\->{db.password},
\&        tunnel_hostname => \*(Aqmy.bastion.host\*(Aq
\&    }
.Ve
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
.ie n .SS "new($entity, $coordinate, %options)"
.el .SS "new($entity, \f(CW$coordinate\fP, \f(CW%options\fP)"
.IX Subsection "new($entity, $coordinate, %options)"
Constructs a new database provider instance.  Should be called on a subclass.
Subclasses should \fI\s-1NOT\s0\fR override this method, rather, override \f(CW\*(C`_init\*(C'\fR.  See
Footprintless::MixableBase for details.
.SH "METHODS"
.IX Header "METHODS"
.SS "backup($to, [%options])"
.IX Subsection "backup($to, [%options])"
Will backup the database to \f(CW$to\fR.  The allowed values for \f(CW$to\fR are:
.PP
\&\- Another instance of the same provider to pipe to the \f(CW\*(C`restore\*(C'\fR method
\&\- A callback method to call with each \fIchunk\fR of the backup
\&\- A \f(CW\*(C`GLOB\*(C'\fR to write to
\&\- A filename to write to
.PP
The options are determined by the implementation.
.SS "\fIbegin_transaction()\fP"
.IX Subsection "begin_transaction()"
Begins a transaction.
.SS "client([%options])"
.IX Subsection "client([%options])"
Will open an interactive client connected to the database.
.SS "\fIcommit_transaction()\fP"
.IX Subsection "commit_transaction()"
Commits the current transaction.
.SS "\fIconnect()\fP"
.IX Subsection "connect()"
Opens a connection to the database.
.SS "\fIdisconnect()\fP"
.IX Subsection "disconnect()"
Closes the current connection to the database.
.SS "execute($query)"
.IX Subsection "execute($query)"
Executes \f(CW$query\fR and returns the number of rows effected.
.SS "\fIget_schema()\fP"
.IX Subsection "get_schema()"
Returns the configured schema name.
.ie n .SS "query($query, $row_handler, %options)"
.el .SS "query($query, \f(CW$row_handler\fP, \f(CW%options\fP)"
.IX Subsection "query($query, $row_handler, %options)"
Executes \f(CW$query\fR and calls \f(CW$row_handler\fR once for each row.  Does not return
anything. If you do not set the \f(CW\*(C`hash\*(C'\fR option, the \f(CW$row_handler\fR gets the 
field data in the \f(CW@_\fR array (see \f(CW\*(C`hash\*(C'\fR option below).
.PP
The following options may be set:
.ie n .IP """column_info""" 4
.el .IP "\f(CWcolumn_info\fR" 4
.IX Item "column_info"
To get column information, set this option to an array ref \- when the query is
executed, before the \f(CW$row_handler\fR is called for the first time, the array
will be populated with the column information, the indexed by result column.
This array may be empty if the underlying driver does not support column
information.
.Sp
Each item in the array will be a hash containing the following properties if
the driver does not support a field it will be missing:
.RS 4
.ie n .IP """name""" 4
.el .IP "\f(CWname\fR" 4
.IX Item "name"
The column name
.ie n .IP """type""" 4
.el .IP "\f(CWtype\fR" 4
.IX Item "type"
The \s-1SQL\s0 type identified by number \- these are supposedly cataloged as part of
the \s-1ISO/IEC 9075\s0 type registry \- but I would not know because this particular
spec seems to be a particularly well guarded secret (I could not get it for
free on the internet). I suggest looking directly at the \f(CW\*(C`type_name\*(C'\fR and 
\&\f(CW\*(C`type_info\*(C'\fR properties instead of worrying about this.
.ie n .IP """type_name""" 4
.el .IP "\f(CWtype_name\fR" 4
.IX Item "type_name"
The \s-1SQL\s0 type identified by name.
.ie n .IP """type_info""" 4
.el .IP "\f(CWtype_info\fR" 4
.IX Item "type_info"
A single \f(CW\*(C`type_info\*(C'\fR hash describing the type for the column as
described at http://search.cpan.org/~timb/DBI\-1.637/DBI.pm#type_info
.ie n .IP """column_size""" 4
.el .IP "\f(CWcolumn_size\fR" 4
.IX Item "column_size"
The precision of the column. For numeric types, this is the number of digits
(does not include sign, decimal point, or even exponent digits). For character
based types, this is the number of bytes which may or may not correspond to
the number of characters.
.ie n .IP """scale""" 4
.el .IP "\f(CWscale\fR" 4
.IX Item "scale"
An integer indicating \*(L"scale\*(R" or \f(CW\*(C`undef\*(C'\fR for types where scale is not used.
.ie n .IP """nullable""" 4
.el .IP "\f(CWnullable\fR" 4
.IX Item "nullable"
Indicates whether or not we can assign this column to null \- \f(CW\*(C`undef\*(C'\fR if the
nullability is unknown. Otherwise this may be evaluated a boolean.
.RE
.RS 4
.RE
.ie n .IP """hash""" 4
.el .IP "\f(CWhash\fR" 4
.IX Item "hash"
Set this to a true value to get the parameters to the \f(CW$row_handler\fR to be set up
suitable for a hash assignment. The actual parameters are an array, but will
now come as: column\-name\-1 => field\-1, column\-name\-2 => field\-2...
.ie n .IP """no_fetch""" 4
.el .IP "\f(CWno_fetch\fR" 4
.IX Item "no_fetch"
Set this to a true value to skip the fetching of data from a result set \- this is
useful for \*(L"queries\*(R" that have no result set and would throw an exception when
we attempt to fetch a row (i.e. \f(CW\*(C`ALTER SESSION\*(C'\fR queries).
.ie n .SS "query_for_list($query, [$row_mapper,] %options)"
.el .SS "query_for_list($query, [$row_mapper,] \f(CW%options\fP)"
.IX Subsection "query_for_list($query, [$row_mapper,] %options)"
Executes \f(CW$query\fR and calls \f(CW$row_mapper\fR once for each row.  \f(CW$row_mapper\fR is
expected to return a scalar representing the row.  All of the returned scalars will
be collected into a list and returned.  When called in list context, a list is
returned.  In scalar context, an arrayref is returned.  If \f(CW$row_mapper\fR is not
supplied, each rows values will be returned as an arrayref (or as hashref if the
\&\f(CW\*(C`hash\*(C'\fR option is selected). For information about the \f(CW\*(C`options\*(C'\fR, see the 
\&\f(CW\*(C`query()\*(C'\fR method \- being that they are the same options.
.ie n .SS "query_for_map($query, [$row_mapper,] %options)"
.el .SS "query_for_map($query, [$row_mapper,] \f(CW%options\fP)"
.IX Subsection "query_for_map($query, [$row_mapper,] %options)"
Executes \f(CW$query\fR and calls \f(CW$row_mapper\fR once for each row.  \f(CW$row_mapper\fR is
expected to return a hashref with a single key/value pair.  All of the returned 
hashrefs will be collected into a single hash and returned.  When called in list 
context, a hash is returned.  In scalar context, a hashref is returned.  If 
\&\f(CW$row_mapper\fR is not supplied, each rows values will be returned as a hashref 
using the first value as the key, and the whole rows arrayref as the value (or
as hashref if the \f(CW\*(C`hash\*(C'\fR option is selected). For information about the
\&\f(CW\*(C`options\*(C'\fR, see the \f(CW\*(C`query()\*(C'\fR method \- being that they are the same options..
.ie n .SS "query_for_scalar($query, $row_mapper)"
.el .SS "query_for_scalar($query, \f(CW$row_mapper\fP)"
.IX Subsection "query_for_scalar($query, $row_mapper)"
Executes \f(CW$query\fR and calls \f(CW$row_mapper\fR once for the first row of the result 
set.  \f(CW$row_mapper\fR is expected to return a scalar representing the row.  If 
\&\f(CW$row_mapper\fR is not supplied, the first value from the first row is returned.
This can be useful for queries like \f(CW\*(C`select count(*) from foo\*(C'\fR.
.ie n .SS "restore($from, %options)"
.el .SS "restore($from, \f(CW%options\fP)"
.IX Subsection "restore($from, %options)"
Will restore the database from \f(CW$from\fR.  The allowed values for \f(CW$from\fR are:
.PP
\&\- Another instance of the same provider to pipe from the \f(CW\*(C`backup\*(C'\fR method
\&\- A hashref containing a \f(CW\*(C`command\*(C'\fR key whose value is a command to pipe input from
\&\- A \f(CW\*(C`GLOB\*(C'\fR to read from
\&\- A filename to read from
.PP
The options are determined by the implementation.
.SS "\fIrollback_transaction()\fP"
.IX Subsection "rollback_transaction()"
Rolls back the current transaction.
.SH "AUTHOR"
.IX Header "AUTHOR"
Lucas Theisen <lucastheisen@pastdev.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2016 by Lucas Theisen.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Please see those modules/websites for more information related to this module.
.IP "\(bu" 4
Footprintless::Plugin::Database
.IP "\(bu" 4
\&\s-1DBI\s0
.IP "\(bu" 4
Footprintless
.IP "\(bu" 4
Footprintless::MixableBase
.IP "\(bu" 4
Footprintless::Plugin::Database
.IP "\(bu" 4
Footprintless::Plugin::Database::CsvProvider
.IP "\(bu" 4
Footprintless::Plugin::Database::MySqlProvider
.IP "\(bu" 4
Footprintless::Plugin::Database::PostgreSqlProvider
