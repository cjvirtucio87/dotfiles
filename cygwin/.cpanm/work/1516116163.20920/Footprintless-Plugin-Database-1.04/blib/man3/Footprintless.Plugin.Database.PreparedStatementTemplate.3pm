.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Footprintless::Plugin::Database::PreparedStatementTemplate 3"
.TH Footprintless::Plugin::Database::PreparedStatementTemplate 3 "2018-01-11" "perl v5.26.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Footprintless::Plugin::Database::PreparedStatementTemplate
.SH "VERSION"
.IX Header "VERSION"
version 1.04
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Footprintless::Plugin::Database::PreparedStatementTemplate;
\&    
\&    my $second_fruit;
\&    my $statement = Footprintless::Plugin::Database::PreparedStatementTemplate\->new(
\&        "SELECT * FROM fruit_basket WHERE fruit IN (\*(Aq_FRUIT_1_\*(Aq, \*(Aq_FRUIT_2_\*(Aq, \*(Aq_FRUIT_3_\*(Aq)",
\&        _FRUIT_1_ => \*(Aqfirst_fruit\*(Aq,
\&        _FRUIT_2_ => sub { $second_fruit },
\&        _FRUIT_3_ => { value => \*(Aqbanana\*(Aq }
\&    );
\&    
\&    my $context = { first_fruit => \*(Aqgrape\*(Aq };
\&    $second_fruit = \*(Aqapple\*(Aq;
\&    
\&    my $query1 = $statement\->query($context);
\&    croak("query1 SQL bad")
\&      unless $query1\->{sql} eq
\&      "SELECT * FROM fruit_basket WHERE fruit IN (\*(Aq?\*(Aq, \*(Aq?\*(Aq, \*(Aq?\*(Aq)";
\&    croak("query1, param[0] bad") unless $query1\->{parameters}\->[0] eq \*(Aqgrape\*(Aq;
\&    croak("query1, param[1] bad") unless $query1\->{parameters}\->[1] eq \*(Aqapple\*(Aq;
\&    croak("query1, param[2] bad") unless $query1\->{parameters}\->[2] eq \*(Aqbanana\*(Aq;
\&    
\&    $context\->{first_fruit} = \*(Aqpear\*(Aq;
\&    $second_fruit = \*(Aqstrawberry\*(Aq;
\&    
\&    my $query2 = $statement\->query($context);
\&    croak("query2 SQL bad")
\&      unless $query2\->{sql} eq
\&      "SELECT * FROM fruit_basket WHERE fruit IN (\*(Aq?\*(Aq, \*(Aq?\*(Aq, \*(Aq?\*(Aq)";
\&    croak("query2, param[0] bad") unless $query2\->{parameters}\->[0] eq \*(Aqpear\*(Aq;
\&    croak("query2, param[1] bad") unless $query2\->{parameters}\->[1] eq \*(Aqstrawberry\*(Aq;
\&    croak("query2, param[2] bad") unless $query2\->{parameters}\->[2] eq \*(Aqbanana\*(Aq;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Footprintless::Plugin::Database::PreparedStatementTemplate
.PP
Prepared statements are a best practice, yet they are a pain in the neck, since
every parameter is represented by a '?' and the parameters are provided in an
array of values that correspond to the '?' in the prepared statement. This
class allows the user to create these painful prepared statements using named
parameters \s-1AND\s0 binding them to a context either by properties, hard-coded values,
and/or closures.
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
.ie n .SS """new($sql_template, %bindings)"""
.el .SS "\f(CWnew($sql_template, %bindings)\fP"
.IX Subsection "new($sql_template, %bindings)"
Creates the prepared statement template with the given bindings. The key of each
binding is the string to replace in the \f(CW$sql_template\fR and the value of each binding
tells this prepared statement template how to bind values to each of the parameters.
The binding value may be one of the following:
.IP "\fBkey\fR" 4
.IX Item "key"
To bind a property from a context, the binding value should be a simple string with
the property name, or a hash-ref like this: \f(CW\*(C`{ key =\*(C'\fR 'property_name' }>
.IP "\fBcode\fR" 4
.IX Item "code"
To bind a property to a value returned from a closure, the binding value should be
a \s-1CODE\s0 (subroutine) ref, or a hash-ref like this: \f(CW\*(C`{ code =\*(C'\fR sub {...} }>
.IP "\fBreference\fR" 4
.IX Item "reference"
To bind a property to a reference (variable), the binding value should be a
scalar-ref, or a hash-ref like this: \f(CW\*(C`{ reference =\*(C'\fR \e$variable }>
.IP "\fBvalue\fR" 4
.IX Item "value"
To bind a property to a constant value, the binding value should be a hash-ref like
this: \f(CW\*(C`{ value =\*(C'\fR 'constant_value' }>
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS """query($context)"""
.el .SS "\f(CWquery($context)\fP"
.IX Subsection "query($context)"
Generate a query acceptable to the \f(CW\*(C`Footprintless::Plugin::Database::AbstractProvider\*(C'\fR
using this prepared statement template and a context to bind to. The context is either
a class instance or hash-ref that has the properties identified in the bindings passed
to the constructor. Properties are primarily a property of the hash-ref, but if it is
not defined, the prepared statement template will attempt to call a no-arg method that
has the name of the property to extract it's value.
.SH "AUTHOR"
.IX Header "AUTHOR"
Lucas Theisen <lucastheisen@pastdev.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2016 by Lucas Theisen.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Please see those modules/websites for more information related to this module.
.IP "\(bu" 4
Footprintless::Plugin::Database
.IP "\(bu" 4
\&\f(CW\*(C`Footprintless::Plugin::Database::AbstractProvider\*(C'\fR
